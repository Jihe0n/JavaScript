<javascript> 

1. 웹브라우저를 프로그래밍적으로 제어하는 언어

2. node.js >> 탈웹브라우저
    자바스크립트가 웹서버 영역까지 확장하는 것 
    웹서버, 웹브라우저 모두를 자바스크립트로 통일할 수 있다

3. 엄격한 동등 연산자 "===" 좌항 우항의 값과 타입도 같아야 True가 나오는 엄격한 연산자
    그냥 무조건 ===를 쓰자 

4. prompt()
    파이썬의 input, C의 scanf과 같은 사용자에게 값을 입력 받는 함수

5. document.write("") 
    script안에서 html안에서 직접 코드를 입력하는 것처럼 웹페이지에 출력하게 하는 명령어 


6. 익명함수 
    (function(){document.write("익명함수");}) (); 
    익명함수 >> 이름이 필요없고 주로 일회성으로 함수 쓸때 많이씀
    자바스크립트는 함수 언어라고 할 정도록 함수가 중요함
  

7. php의 연관배열 > 배열의 인덱스를 문자로 사용하여 가독성을 높이는 것
    javascript 에서는 객체를 만듬 >> { }, object 


8. 객체의 object['a'] // object.a 는 같은 뜻 이지만
    object['a'+'b'] 등으로 활용할 수 있는 장점이 있어서 필요에 의해 쓰면 편리 

9. 배열을 내부적으로 순서를 가지고있음 (추가된 순서)
    하지만 객체는 key : value로 나누워졌지 순서를 가지지 않음

10. 객체 or 배열에서 for문 쓸때  >> 처럼 파이썬의 for문 같은 형태로 씀  
    for( key in obj){
    }

11. this의 의미 // 어떤 호출에서 쓰냐에 따라 다르지만 일반적으로 
    속해있는 객체를 가리킴 >> 만약 함수내부나 객체에서 쓴게 아니면 window를 뜻함
    따라서 this로 변수를 선언하면 전역변수로 선언됨

12. <script src=""></script> 의 의미 
    >> script를 보면 일단 src를 확인하고 그 값을 읽어서 script안쪽에 넣는다의 의미


13. 변수 선언시 var은 명시적으로 local 변수를 생성함을 뜻함 // 함수밖에서 쓰면 전역변수로 선언됨 
    유효범위(scope) > 변수의 수명 

14. 자바스크립트의 유효범위의 대상 
    자바스크립트는 다른 언어와 다르게 함수에 대한 유효범위만을 제공함 무슨 뜻이냐하면 
    함수내부가 아닌 for문 if문 안에서 var로 변수선언을 해도 전역변수로 제공함
    따라서 함수의 내부에서 선언된 변수만이 지역변수로써의 의미를 가짐 

15. 자바스크립트는 정적 유효범위를 가짐 >> 함수가 선언된 시점에서 유효범위를 가짐

16. 객체의 속성으로 담겨진 함수를 메소드라고 부름

17. 자바스크립트의 함수는 값이다 >> 그렇기때문에 변수에 저장되며 객체의 속성으로도 사용될 수 있다.
    함수의 인자로도 전달 될 수있고 return값으로도 함수, 배열의 값으로도 함수가 사용가능하다.

18. 콜백함수 >> 순차적으로 실행하고 싶을때 사용하는 함수

18. 비동기 처리란 
    페이지 전체를 리로딩 하는게 아니라 필요한 부분만 웹서버 한테 요청한다 (그냥 막연히 알던 것)
    특정 로직의 실행이 끝날 때까지 대기하지 않고, 나머지 코드를 먼저 실행하는 것이 비동기 처리이다.
    요청을 보낸 후 응답에 관계 없이 다음 동작을 실행

19. 자바스크립트에서 비동기 처리가 필요한 이유
    화면에서 서버로 데이터를 요청했을 때 서버가 응답값을 언제 줄지도 모르는데 마냥 기다릴 순 없기 때문이다

    비동기방식에서 어떤 주소로 데이터를 요청하고 리턴값을 받아와야 되는데
    요청하고 응답값을 받아오기 전에 리턴이 되서 undefined가 받아와짐

    이러한 비동기 처리의 방식을 해결하기 위해서 순서를 보장하기위해 콜백함수를 사용하는데
    여러개의 콜백함수가 중첩되면 복잡해지기 때문에 promise 방식이나 최신 자바스크립트의 fetch, then등을 사용
    하거나 혹은 리액트나 뷰에서는 axios라는 외부 라이브러리 사용  


20. 클로저(closure) // 어떤 문법이라기보단 매커니즘의 일환
    내부함수가 외부함수의 맥락의 접근할 수 있을 뿐만 아니라 외부함수가 종료된 이후에도 
    내부함수를 통해 외부함수에 접근 할 수 있는 것 
    내부함수가 외부함수의 지역변수에 접근할 경우에 그 내부함수가 만들어지는 시점에서의 
    외부함수의 지역변수값을 갖고있음

21. arguments // 유사배열 
    자바스크립트는 매우 관대하기때문에 함수에서 인자나 매개변수를 맞추지않아도 에러나지않음
    함수를 호출할때 사용자가 준 인자에 접근할 수 있는 마치 배열과 비슷한 객체
    몇개의 인자가 들어올지 예측할 수 없을때 매개변수를 선언 하지않고 arguments라는 약속된
    객체를 통해서 인자의 접근 하는 것 

22. function.length // 함수의 매개변수의 개수가 나옴 
    때에 따라서는 함수의 매개변수와 호출시의 인자개수가 반드시 맞아야만 하는 경우가 
    있을 수 있기때문에 그경우 function.length와 arguments.length를 비교하면 효율적


23. 배열은 물론 함수는 객체이다 의식하고있지 않지만 Function이라는 클래스의 인스턴스이다.
    그렇기때문에 클래스의 메소드인 apply, call등을 사용할 수 있다

24. apply // 함수의 내장 메소드 
    func.apply(obj) >> func를 obj라는 객체의 메소드로 사용하겠다는 의미를 나타냄
    따라서 obj.func()와 같은 뜻으로 여기서 func의 this는 obj를 가리킴
    물론 여기서 func와 obj는 서로 독립적
    따라서 apply는 함수가 호출되는 시점의 this값을 obj의 메소드인 것처럼 실행하게 해주는 것

25. 객체지향이란 > 로직을 상태와 행위로 이루어진 객체로 연관된 애들끼리 그룹핑 하는 것 
    객체를 통해 독립성을 갖고 하나의 부품으로써 로직을 만드는 것 

26. 객체의 속성 > 프로퍼티

27. 자바스크립트의 생성자 
    var a = new function() // new는 생성자를 호출하여 비어있는 객체를 만듬 
    자바의 경우 생성자가 클래스안에 소속되어 있지만 자바스크립트는 소속되어있지않고 그냥 함수임 
    생성자 라는 것은 결국 객체를 *초기화* 시켜서 만들어준다 


28. window // 자바스크립트의 전역객체의 이름 


29. this // 호출한 상황에따라 가변적임, 함수와 객체의 관계의 *연결고리 >> 변화무쌍하다
    함수안에서는 this -> window // 함수가 어떤 객체의 소속되있지않으면 그건 전역객체의 소속이기때문에 
    객체안에서의 this -> 객체의 이름
    new를 통한 생성자로써의 this -> 생성된 객체의 이름 

    즉 this라는 것은 결국 어떤 객체가 생성자에 의해 생성이 되고 아직 변수에 담기기 전에 
    아직 선언되지않은 그 객체를 참조할 수 있는 식별자를 뜻함    


30. prototype(원형) // 함수의 내장 메소드 
    new + 생성자로 단순히 비어있는 객체를 만드는 것은 아무 의미가 없음
    함수의 내장메소드인 prototype에 객체를 저장해놨다가 new를 통해서 생성자를 호출하게 되면 
    생성자함수의 prototype에 저장되어있는 객체를 꺼내서 리턴해줌 


31. 상속
    생성자의 프로토타입에 상속할 객체를 할당한다
    어떠한 객체를 상속받고싶다면 상속받을 객체의 프로토타입에 new를 통해 상속할 객체를 생성하는 것 
    그러면 결국 하위객체를 생성할때 그의 프로토 타입으로 부모에있는 프로퍼티를 사용할 수 있음 


32. 내장메소드 hasOwnProperty ****
    obj1.hasOwnProperty('obj1') // obj1객체가 인자로 전달한 obj2의 프로퍼티를 자신의 프로퍼티로 갖고있는가?
    그래서 프로퍼티가 같으면 True가 반환될 것이고, prototype을 통해 상속받았다면 obj1이 없는 프로퍼티를
    갖고있을테니까 직접 소유냐 아니냐 를 체크하여 상속받은건지 내가 직접 선언한건지 분별가능   

33. Wrapper 객체
    String, Number, Boolean 등의 객체가 아닌 데이터 타입을 원시 데이터타입 이라고 함 
    하지만 str.length 등과같이 객체가 아닌 원시 데이터타입을 마치 객체처럼 쓸 수 있는 것은  
    자바스크립트가 내부적으로 객체화를 시켜버림 이때 자동으로 만들어지는 객체가 Wrapper객체 
    원시데이터 타입은 객체가 아니지만 Wrapper객체 때문에 마치 객체처럼 사용이 가능함



34. 화살표 함수(Arrow function) // ES6 이상 
    var foo = () => console.log('bar'); // 매개변수가 없는경우
    var foo = x => x;  // 매개변수가 있는경우
    var foo = (a, b) => a + b; // 매개변수 2개이상
    var foo = (a, b) => { return a + b };  // 대괄호({})를 사용하면 여러줄로 쓸수있지만 return을 줘야댐 



35. 문자열을 숫자로 바꾸는 방법 
    Number(str) // 숫자가 아닌것이 들어오면 NaN
    parseInt(str) // 숫자+문자 의 경우 숫자가 끝날때 까지만 잘라서 int로 변환, 숫자가 아니면 Number랑 같음


36. 숫자를 문자열로 바꾸는 방법
    String(123) // '123'
    (123).toString() // '123'   

37. 삼항 연산자
    (조건문) ? '참일때' : '거짓일때' 


38. asyn, defer
    <script asyn // 파싱과 js 다운로드를 병렬로 처리함 > 시간절약이 되지만, 전부 파싱되기전에 js가 실행될수있음
    <script defer // 가장 좋은 옵션 > 다운로드는 병렬로 하고 파싱이 다 된다음에 js 실행
 

39.  'use strict'  // 엄격한 모드 
    자바스크립트는 유연하고 매우 관대한 언어라서 에러가 있어도 치명적이지 않으면 문제가 생기지않음 
    그리고 엔진이 좀더 빠르고 효율적으로 분석하여 속도개선에도 좋은 영향을 줌, 되도록이면 쓰자


40. var를 쓰면 안되는 이유  >> 그냥 무조건 let 쓰면댐 
    1. hoisting (끌어 올려주다)
        자바스크립트의 var의 특징중 하나로 어디서 변수를 사용하던간에 var를 쓰면 맨위로 끌어 올려줌 
        a = 3  
        var a 
        그래서 이런 말도 안되는 코드를 써도 오류가 나지않음 
    
    2. no block scope // 블럭을 철저히 무시함
        블럭 안에서 선언한 지역변수는 밖에서 쓸수 없는 것이 정상이데 var는 무시해버림  
        옛날에는 대충짜도 코드가 동작 하도록 유연성있는 변수를 사용했지만, 규모가 점점 커짐에따라 
        선언하지도 않은게 갑자기 튀어나오는 불상사가 발생해서 var를 쓰면 안됨 위험부담이 큼


41. const 변수 (constant / 일정한)
    const 변수가 선언되면 변수의 주소를 가리키는 포인터가 잠김 그래서  
    한번 할당하면 절대 값이 바뀌지 않는 변수 JAVA의 finall 같은거 
    변경 불가능한 immutable타입
    앞으로 변경 될 일이 없다면 const로 선언하는 것이 바람직 

     
42. first-class-function
    javascript처럼 함수가 하나의 datatype으로 값으로써 존하기 때문에
    function을 함수의 인자라던지 return값으로 반환 한다던지 하는 것을 first-class-function 라고 한다.


43 static typing vs dynamic typing
    동적 타이핑(dynamic typing)은 변수를 선언하는데 있어서 컴퓨터적 구조를 생략하고 데이터 타입을 명시하지
    않아도 컴퓨터가 알아서 해석하게 냅둔다 그래서 a=3, a="hello" 처럼 코드를 더 간결하게 해주고 직관적으로 
    만들어 주지만 데이터 타입을 컴퓨터 에게 맡기기 때문에 속도가 더 느리다 // 자바스크립트는 동적타이핑을 제공

    반면 정적 타이핑(static typing)은 직접 데이터타입을 명시해줌 으로써 컴퓨터가 해야할 일을 줄여주고
    작은 정보까지도 개발자가 신경쓰고 그만큼 코드가 정교하고 안정성이 높아진다. 하지만 복잡하고 어렵다 
    

44. typeof
    자바스크립트의 데이터 타입확인 
    괄호없이써도 되고 괄호를 써도된다 // typeof variable == typeof(variable)


45. [Template literals] // ES6 부터 지원   
    멀티라인을 쓰거나 템플릿 문법으로 마치 f스트링 그런 비슷한 느낌인듯 
    역따옴표(`) 를사용하여 문장을 담고 템플릿 문법 ${}를 사용하여 javascript의 변수, 수식등을 사용가능 
    ex) `eqweqwe${test?1:0}ssadasd` // 멀티라인은 쓰면서 삼항 연산자를 사용한 예시 

46. Symbol()
    정말 고유한 식별자가 필요할때 사용하거나 동시다발적인 코드에서 우선순위를 줄때 식별자로 구분하여 사용 
    식별자를 str로 쓸수도있지만 Symbol은 유일해서 중복되거나 하지않음
    Symbol은 자동 형변환이 안되기 때문에 출력할때는 Symbol_name.description로 문자열 형태로 출력해야됨 


47. charAt(i)
    str = "hello"
    str.charAt(0) // h
    문자열의 프로퍼티로 인덱스 위치에 존재하는 문자를 반환 

48. typescript 
    자바스크립트는 유연성과 자유도가 높아서 쉽고 편리하다.
    하지만 프로젝트의 규모가 커짐에 따라 이러한 장점은 자바스크립트의 단점이 된다.  
    그래서 javascript 위에 엄격한 type이 덮혀서 typescript를 쓴다. 
    근데 typescript는 브라우저에서 지원하지않아서 babel 등으로 transcompiler를 해야됨 

49. const obj = {name:"ko"}
    객체를 const로 선언하면 뭔가 바꿀수 없을 것 같은데 가리키는 포인터가 잠긴것 이기때문에 
    객체 자체를 바꿀수 없는거지 객체 안에 변수는 바꿀수있다 obj.name = "jp"

50. 논리연산자 '||' , '&&' 
    얘네들은 오해하기 쉬운게 단순히 참 거짓을 판단해 주는 연산자들이 아니라 값을 반환한다
    or의 경우 하나만 참이여도 참이기 때문에 앞의 값이 참이면 뒤에값은 읽는 것 조차 하지않는다
    그리고 그때 참의 값을 반환하는 것이다, 이를 통해 연산이 필요한 함수같은 로직을 이 논리 연산자에
    앞쪽에 배치해서는 당연히 안된다 ex) a || fun() // 심플한 애들을 앞에 놓고 마지막에 마지못해 
    함수가 실행되어 최대한 연산을 피하는 효율적인 코드 테크닉이 필요하다 // and도 당연히 마찬가지

51. switch문 
    case a:
    case b: 
    케이스 안의 동작하는 내용이 정확히 같다면 연달아서 쓰면됨  
    
    
52. label // 현업에서는 최대한 자제한다고 함 
    반복문에 레이블을 붙이고, break나 continue 구문을 사용해 반복문의 어느 위치에서 작업을 멈추고 
    어느 위치에서 다시 수행할지를 알려줄 수 있다.
    ex) 2중for문에서 각 for문에 라벨을 정의해놓으면 안쪽 for문에서 break outterloop 이런식으로 한번에 탈출가능
    label_name : for(~~)






































viewport 

toString


 























 

