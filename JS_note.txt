<javascript> 

1. 웹브라우저를 프로그래밍적으로 제어하는 언어

2. node.js >> 탈웹브라우저
    자바스크립트가 웹서버 영역까지 확장하는 것 
    웹서버, 웹브라우저 모두를 자바스크립트로 통일할 수 있다

3. 엄격한 동등 연산자 "===" 좌항 우항의 값과 타입도 같아야 True가 나오는 엄격한 연산자
    그냥 무조건 ===를 쓰자 

4. prompt()
    파이썬의 input, C의 scanf과 같은 사용자에게 값을 입력 받는 함수

5. document.write("") 
    script안에서 html안에서 직접 코드를 입력하는 것처럼 웹페이지에 출력하게 하는 명령어 
    웹 페이지가 로딩될 때 실행되면, 웹 페이지에 가장 먼저 데이터를 출력합니다.
    하지만 웹 페이지의 모든 내용이 로딩된 후에 document.write() 메소드가 실행되면, 
    웹 페이지 내에 먼저 로딩된 모든 데이터를 지우고 자신의 데이터를 출력하게 됩니다.
    따라서 document.write() 메소드를 테스트 이외의 용도로 사용할 때에는 주의


6. 익명함수 
    (function(){document.write("익명함수");}) (); 
    익명함수 >> 이름이 필요없고 주로 일회성으로 함수 쓸때 많이씀
    자바스크립트는 함수 언어라고 할 정도록 함수가 중요함

6-1 인자로서의 함수
    함수의 인자로 함수를 넘겨줄때는 outerfunc(func) 처럼 이름만 줘야지
    func()같이 ()가 붙으면 얘는 실행을 해버리니까 값으로써가 아니라 함수자체를 넘길땐 이름만 넘긴다 
    함수의 이름은 그함수를 가리키는 것일 뿐임 


7. php의 연관배열 > 배열의 인덱스를 문자로 사용하여 가독성을 높이는 것
    javascript 에서는 객체를 만듬 >> { }, object 


8. 객체의 object['a'] // object.a 는 같은 뜻 이지만
    object['a'+'b'] 등으로 활용할 수 있는 장점이 있어서 필요에 의해 쓰면 편리 

9. 배열을 내부적으로 순서를 가지고있음 (추가된 순서)
    하지만 객체는 key : value로 나누워졌지 순서를 가지지 않음

10. for ... in , for ... of 
    for(var key in obj) // for in은 객체 순환
    for(var value of arr) // for of는 배열 순환 >> 얘는 배열의 인덱스가 아니라 값이나옴


11. this의 의미 // 어떤 호출에서 쓰냐에 따라 다르지만 일반적으로 
    속해있는 객체를 가리킴 >> 만약 함수내부나 객체에서 쓴게 아니면 window를 뜻함
    따라서 this로 변수를 선언하면 전역변수로 선언됨

12. <script src=""></script> 의 의미 
    >> script를 보면 일단 src를 확인하고 그 값을 읽어서 script안쪽에 넣는다의 의미


13. 변수 선언시 var은 명시적으로 local 변수를 생성함을 뜻함 // 함수밖에서 쓰면 전역변수로 선언됨 
    유효범위(scope) > 변수의 수명 

14. 자바스크립트의 유효범위의 대상 
    자바스크립트는 다른 언어와 다르게 함수에 대한 유효범위만을 제공함 무슨 뜻이냐하면 
    함수내부가 아닌 for문 if문 안에서 var로 변수선언을 해도 전역변수로 제공함
    따라서 함수의 내부에서 선언된 변수만이 지역변수로써의 의미를 가짐 

15. 자바스크립트는 정적 유효범위를 가짐 >> 함수가 선언된 시점에서 유효범위를 가짐

16. 객체의 속성으로 담겨진 함수를 메소드라고 부름

17. 자바스크립트의 함수는 값이다 >> 그렇기때문에 변수에 저장되며 객체의 속성으로도 사용될 수 있다.
    함수의 인자로도 전달 될 수있고 return값으로도 함수, 배열의 값으로도 함수가 사용가능하다.

18. 콜백함수 >> 순차적으로 실행하고 싶을때 사용하는 함수

18. 비동기 처리란 
    페이지 전체를 리로딩 하는게 아니라 필요한 부분만 웹서버 한테 요청한다 (그냥 막연히 알던 것)
    특정 로직의 실행이 끝날 때까지 대기하지 않고, 나머지 코드를 먼저 실행하는 것이 비동기 처리이다.
    요청을 보낸 후 응답에 관계 없이 다음 동작을 실행
    자바스크립트의 비동기 처리는  XMLHttpRequest 메소드를 사용 하는데 
    최신 자바스크립트에서는 fetch, then등을 사용 혹은 리액트나 뷰에서는 axios라는 외부 라이브러리 사용  

19. 자바스크립트에서 비동기 처리가 필요한 이유
    화면에서 서버로 데이터를 요청했을 때 서버가 응답값을 언제 줄지도 모르는데 마냥 기다릴 순 없기 때문이다

    비동기방식에서 어떤 주소로 데이터를 요청하고 리턴값을 받아와야 되는데
    요청하고 응답값을 받아오기 전에 리턴이 되서 undefined가 받아와짐

    이러한 비동기 처리의 방식을 해결하기 위해서 순서를 보장하기위해 콜백함수를 사용하는데
    여러개의 콜백함수가 중첩되면 복잡해지기 때문에 promise 방식사용

    자바스크립트 엔진은 기본적으로 한줄 실행 끝나면 그다음 한줄 실행을 반복하는 동기처리를 하기때문에 
    오래걸리는 코드에 비동기 처리를 하지 않으면 그러한 오래걸리는 (네트워크, 파일읽어오기 등)을 처리하게되고
    만약 이러한 코드 뒤에 웹페이지의 ui를 나타내는 코드들이 있다면 사용자는 비어있는 웹페이지를 볼수밖에 없음 



    

20. 클로저(closure) // 어떤 문법이라기보단 매커니즘의 일환
    내부함수가 외부함수의 맥락의 접근할 수 있을 뿐만 아니라 외부함수가 종료된 이후에도 
    내부함수를 통해 외부함수에 접근 할 수 있는 것 
    내부함수가 외부함수의 지역변수에 접근할 경우에 그 내부함수가 만들어지는 시점에서의 
    외부함수의 지역변수값을 갖고있음

21. arguments // 유사배열 
    자바스크립트는 매우 관대하기때문에 함수에서 인자나 매개변수를 맞추지않아도 에러나지않음
    함수를 호출할때 사용자가 준 인자에 접근할 수 있는 마치 배열과 비슷한 객체
    몇개의 인자가 들어올지 예측할 수 없을때 매개변수를 선언 하지않고 arguments라는 약속된
    객체를 통해서 인자의 접근 하는 것 

22. function.length // 함수의 매개변수의 개수가 나옴 
    때에 따라서는 함수의 매개변수와 호출시의 인자개수가 반드시 맞아야만 하는 경우가 
    있을 수 있기때문에 그경우 function.length와 arguments.length를 비교하면 효율적


23. 배열은 물론 함수는 객체이다 의식하고있지 않지만 Function이라는 클래스의 인스턴스이다.
    그렇기때문에 클래스의 메소드인 apply, call등을 사용할 수 있다

24. apply // 함수의 내장 메소드 
    func.apply(obj) >> func를 obj라는 객체의 메소드로 사용하겠다는 의미를 나타냄
    따라서 obj.func()와 같은 뜻으로 여기서 func의 this는 obj를 가리킴
    물론 여기서 func와 obj는 서로 독립적
    따라서 apply는 함수가 호출되는 시점의 this값을 obj의 메소드인 것처럼 실행하게 해주는 것

25. 객체지향이란 > 로직을 상태와 행위로 이루어진 객체로 연관된 애들끼리 그룹핑 하는 것 
    객체를 통해 독립성을 갖고 하나의 부품으로써 로직을 만드는 것 

26. 객체의 속성 > 프로퍼티

27. 자바스크립트의 생성자 
    var a = new function() // new는 생성자를 호출하여 비어있는 객체를 만듬 
    자바의 경우 생성자가 클래스안에 소속되어 있지만 자바스크립트는 소속되어있지않고 그냥 함수임 
    생성자 라는 것은 결국 객체를 *초기화* 시켜서 만들어준다 


28. window // 자바스크립트의 전역객체의 이름 


29. this // 호출한 상황에따라 가변적임, 함수와 객체의 관계의 *연결고리 >> 변화무쌍하다
    함수안에서는 this -> window // 함수가 어떤 객체의 소속되있지않으면 그건 전역객체의 소속이기때문에 
    객체안에서의 this -> 객체의 이름
    new를 통한 생성자로써의 this -> 생성된 객체의 이름 

    즉 this라는 것은 결국 어떤 객체가 생성자에 의해 생성이 되고 아직 변수에 담기기 전에 
    아직 선언되지않은 그 객체를 참조할 수 있는 식별자를 뜻함    


30. prototype(원형) // 함수의 내장 메소드 
    new + 생성자로 단순히 비어있는 객체를 만드는 것은 아무 의미가 없음
    함수의 내장메소드인 prototype에 객체를 저장해놨다가 new를 통해서 생성자를 호출하게 되면 
    생성자함수의 prototype에 저장되어있는 객체를 꺼내서 리턴해줌 


31. 상속
    생성자의 프로토타입에 상속할 객체를 할당한다
    어떠한 객체를 상속받고싶다면 상속받을 객체의 프로토타입에 new를 통해 상속할 객체를 생성하는 것 
    그러면 결국 하위객체를 생성할때 그의 프로토 타입으로 부모에있는 프로퍼티를 사용할 수 있음 


32. 내장메소드 hasOwnProperty ****
    obj1.hasOwnProperty('obj1') // obj1객체가 인자로 전달한 obj2의 프로퍼티를 자신의 프로퍼티로 갖고있는가?
    그래서 프로퍼티가 같으면 True가 반환될 것이고, prototype을 통해 상속받았다면 obj1이 없는 프로퍼티를
    갖고있을테니까 직접 소유냐 아니냐 를 체크하여 상속받은건지 내가 직접 선언한건지 분별가능   

33. Wrapper 객체
    String, Number, Boolean 등의 객체가 아닌 데이터 타입을 원시 데이터타입 이라고 함 
    하지만 str.length 등과같이 객체가 아닌 원시 데이터타입을 마치 객체처럼 쓸 수 있는 것은  
    자바스크립트가 내부적으로 객체화를 시켜버림 이때 자동으로 만들어지는 객체가 Wrapper객체 
    원시데이터 타입은 객체가 아니지만 Wrapper객체 때문에 마치 객체처럼 사용이 가능함



34. 화살표 함수(Arrow function) // ES6 이상 
    함수를 변수에 담는 표현은 function키워드도 쓰고, 대괄호도 쓰고 번거로움 그것들을 생략 하게 함
    한줄이니 경우는 블럭없이 가능하지만 여러줄은 블럭을 쓰고 return을 줘야댐 
    var foo = () => console.log('bar'); // 매개변수가 없는경우
    var foo = x => x;  // 매개변수가 있는경우
    var foo = (a, b) => a + b; // 매개변수 2개이상
    var foo = (a, b) => { return a + b };  // 대괄호({})를 사용하면 여러줄로 쓸수있지만 return을 줘야댐 



35. 문자열을 숫자로 바꾸는 방법 
    Number(str) // 숫자가 아닌것이 들어오면 NaN
    parseInt(str) // 숫자+문자 의 경우 숫자가 끝날때 까지만 잘라서 int로 변환, 숫자가 아니면 Number랑 같음


36. 숫자를 문자열로 바꾸는 방법
    String(123) // '123'
    (123).toString() // '123'   

37. 삼항 연산자
    (조건문) ? '참일때' : '거짓일때' 


38. asyn, defer
    <script asyn // 파싱과 js 다운로드를 병렬로 처리함 > 시간절약이 되지만, 전부 파싱되기전에 js가 실행될수있음
    <script defer // 가장 좋은 옵션 > 다운로드는 병렬로 하고 파싱이 다 된다음에 js 실행
 

39.  'use strict'  // 엄격한 모드 
    자바스크립트는 유연하고 매우 관대한 언어라서 에러가 있어도 치명적이지 않으면 문제가 생기지않음 
    그리고 엔진이 좀더 빠르고 효율적으로 분석하여 속도개선에도 좋은 영향을 줌, 되도록이면 쓰자


40. var를 쓰면 안되는 이유  >> 그냥 무조건 let 쓰면댐 
    1. hoisting (끌어 올려주다)
        자바스크립트의 var의 특징중 하나로 어디서 변수를 사용하던간에 var를 쓰면 맨위로 끌어 올려줌 
        a = 3  
        var a 
        그래서 이런 말도 안되는 코드를 써도 오류가 나지않음 
    
    2. no block scope // 블럭을 철저히 무시함
        블럭 안에서 선언한 지역변수는 밖에서 쓸수 없는 것이 정상이데 var는 무시해버림  
        옛날에는 대충짜도 코드가 동작 하도록 유연성있는 변수를 사용했지만, 규모가 점점 커짐에따라 
        선언하지도 않은게 갑자기 튀어나오는 불상사가 발생해서 var를 쓰면 안됨 위험부담이 큼


41. const 변수 (constant / 일정한)
    const 변수가 선언되면 변수의 주소를 가리키는 포인터가 잠김 그래서  
    한번 할당하면 절대 값이 바뀌지 않는 변수 JAVA의 finall 같은거 
    변경 불가능한 immutable타입
    앞으로 변경 될 일이 없다면 const로 선언하는 것이 바람직 

     
42. first-class-function
    javascript처럼 함수가 하나의 datatype으로 값으로써 존하기 때문에
    function을 함수의 인자라던지 return값으로 반환 한다던지 하는 것을 first-class-function 라고 한다.


43 static typing vs dynamic typing
    동적 타이핑(dynamic typing)은 변수를 선언하는데 있어서 컴퓨터적 구조를 생략하고 데이터 타입을 명시하지
    않아도 컴퓨터가 알아서 해석하게 냅둔다 그래서 a=3, a="hello" 처럼 코드를 더 간결하게 해주고 직관적으로 
    만들어 주지만 데이터 타입을 컴퓨터 에게 맡기기 때문에 속도가 더 느리다 // 자바스크립트는 동적타이핑을 제공

    반면 정적 타이핑(static typing)은 직접 데이터타입을 명시해줌 으로써 컴퓨터가 해야할 일을 줄여주고
    작은 정보까지도 개발자가 신경쓰고 그만큼 코드가 정교하고 안정성이 높아진다. 하지만 복잡하고 어렵다 
    

44. typeof
    자바스크립트의 데이터 타입확인 
    괄호없이써도 되고 괄호를 써도된다 // typeof variable == typeof(variable)


45. [Template literals] // ES6 부터 지원   
    멀티라인을 쓰거나 템플릿 문법으로 마치 f스트링 그런 비슷한 느낌인듯 
    역따옴표(`) 를사용하여 문장을 담고 템플릿 문법 ${}를 사용하여 javascript의 변수, 수식등을 사용가능 
    ex) `eqweqwe${test?1:0}ssadasd` // 멀티라인은 쓰면서 삼항 연산자를 사용한 예시 

46. Symbol()
    정말 고유한 식별자가 필요할때 사용하거나 동시다발적인 코드에서 우선순위를 줄때 식별자로 구분하여 사용 
    식별자를 str로 쓸수도있지만 Symbol은 유일해서 중복되거나 하지않음
    Symbol은 자동 형변환이 안되기 때문에 출력할때는 Symbol_name.description로 문자열 형태로 출력해야됨 


47. charAt(i)
    str = "hello"
    str.charAt(0) // h
    문자열의 프로퍼티로 인덱스 위치에 존재하는 문자를 반환 

48. typescript 
    자바스크립트는 유연성과 자유도가 높아서 쉽고 편리하다.
    하지만 프로젝트의 규모가 커짐에 따라 이러한 장점은 자바스크립트의 단점이 된다.  
    그래서 javascript 위에 엄격한 type이 덮혀서 typescript를 쓴다. 
    근데 typescript는 브라우저에서 지원하지않아서 babel 등으로 transcompiler를 해야됨 

49. const obj = {name:"ko"}
    객체를 const로 선언하면 뭔가 바꿀수 없을 것 같은데 가리키는 포인터가 잠긴것 이기때문에 
    객체 자체를 바꿀수 없는거지 객체 안에 변수는 바꿀수있다 obj.name = "jp"

50. 논리연산자 '||' , '&&' 
    얘네들은 오해하기 쉬운게 단순히 참 거짓을 판단해 주는 연산자들이 아니라 값을 반환한다
    or의 경우 하나만 참이여도 참이기 때문에 앞의 값이 참이면 뒤에값은 읽는 것 조차 하지않는다
    그리고 그때 참의 값을 반환하는 것이다, 이를 통해 연산이 필요한 함수같은 로직을 이 논리 연산자에
    앞쪽에 배치해서는 당연히 안된다 ex) a || fun() // 심플한 애들을 앞에 놓고 마지막에 마지못해 
    함수가 실행되어 최대한 연산을 피하는 효율적인 코드 테크닉이 필요하다 // and도 당연히 마찬가지

51. switch문 
    case a:
    case b: 
    케이스 안의 동작하는 내용이 정확히 같다면 연달아서 쓰면됨  
    
    
52. label // 현업에서는 최대한 자제한다고 함 
    반복문에 레이블을 붙이고, break나 continue 구문을 사용해 반복문의 어느 위치에서 작업을 멈추고 
    어느 위치에서 다시 수행할지를 알려줄 수 있다.
    ex) 2중for문에서 각 for문에 라벨을 정의해놓으면 안쪽 for문에서 break outterloop 이런식으로 한번에 탈출가능
    label_name : for(~~)


53. 하나의 함수는 하나의 일만 처리해야 한다.

54. default parameters // ES6 이상
    function (a, b="def"){ }
    파이썬에서 배웠던 문법임, 함수를 선언할 때 매개변수에 초기값을 줘서 만약 밖에서 선언할때
    값을 주지 않으면 초기값으로 함수내부에서 동작하는 문법
     
55. function func(...args) {} // ES6 이상
    파이썬의 *args와 같은 원리 함수를 사용하는 사람이 몇개의 인자를 줄지 모르기 때문에
    받아온 값을 배열로 함수내부에서 처리한다.


56. 클로저
    밖에서는 안이 보이지않고, 안에서만 밖을 볼 수 있다는 매커니즘

57. Early return , Early exit
    코드짜는 테크닉인데 코드가 더 깔끔해짐

    bad: 
    function () {
        if(조건){
            logic // 이렇게 조건에 맞으면 로직을 실행하는 코드는 
                  // 블럭 안에서 코드를 많이 짜서 가독성이 떨어짐  
        }
    } 

    good:
    function () {
        if(!조건){
            return // 조건에 맞지 않으면 빨리 리턴을 해서 함수를 종료하고 
        }
        logic // 조건에 맞을때 블럭 밖에서 로직을 실행하는게 더 깔끔함  
    }


58. function의 선언과 hoist 
    함수를 선언해서 값으로써 변수에 담아서 선언하는 방식과 function키워드로 직접 함수를
    선언 하는 것은 언뜻보면 같은 것 같지만 직접선언은 hoist한다는 차이점이 있다
    따라서 함수를 직접선언하면 hoist가되서 선언전에 함수를 사용해도 오류가 나지않는다
    hoist는 자바스크립는 엔진이 선언된 것을 제일위로 올려줌 

59. 익명함수 말고 함수의 이름이 있으면 좋은 점 
    디버깅할때 함수의 이름을 알수 있고, 자기자신을 호출하는 재귀함수를 사용할 수 있다.

60. IIFE // 함수 선언과 동시에 실행
    함수를 ()로 묶고 바로 ()을 옆에 달아서 실행 할 수 있음 

61. 데이터 클래스
    클래스안에 메소드는 없고, 필드만 있는 클래스 

62. 자바스크립트의 객체지향 
    ES6부터 CLASS 가 지원되는 자바스크립는 그전에는 생성자 function을 통해서 객체를 만들었다.
    기존에는 prototype을 이용해서 유사 CLASS같은 느낌으로 객체 지향을 지원했다
    그래서 동작은 prototype 기반으로 동작 하지만 문법만 class를 씌웠다 라고 생각하면됨 

63. 클래스와 생성자 
    class Person {
    constructor(a,b){ // 생성자 
        this.a = a // field
        this.b = b // field
    }// this는 자신이 속한 객체의 이름 여기서는 당연히 Person

    speak(){ // 메소드
    }
}   


64. getter, setter 
    예상치 못한 입력에도 한 소프트웨어가 계속적 기능 수행을 보장할 수 있도록 고안된 방어적 설계를 말함
    객체지향에서 객체의 데이터는 외부에서 직접적으로 접근하는 것을 막는다. 무결성이 깨질수 있기때문이다.
    그래서 메소드를 통해서만 데이터를 변경하는 것을 선호한다. 그래서 직접 접근하는 것을 막고 메소드는
    공개해서 메소드르 통해서만 접근하도록 유도한다 
    get()으로만 접근하여 데이터를 리턴할 수 있도록 하고 set(value)으로만 접근해 값을 설정할 수 있다. 


65. getter와 setter의 변수
    사용자가 객체를 생성하면 그 인자가 생성자로 들어가고 내부적으로 this.age = age 가 실행되는데
    이때 setter가 선언되어있으면 필드의 이름과 같은 setter를 찾아서 실행한다 근데 만약
    setter(value) 안에 this.age = value로 코드를 짠다면 처음 매커니즘처럼 필드의 값이 선언되는 것 이므로
    다시 setter(value) 가 선언되어 무한 콜백이 일어난다 그렇기 때문에 getter, setter 내부에서
    원본 변수랑 다른 이름를 변수를 써야되지만, 정작 사용자는 신경쓰지않고 그냥 age만 쓰면된다
    getter도 같은 원리 쉽게말해 getter, setter안에서 이름이 다른 변수를 사용해야됨 

66. 자바스크립의 상속과 다양성 
    class를 사용하면 extends를 사용하여 부모를 상속 받을 수 있다.
    재정의가 필요한 함수를 재정의 하는 오버라이딩을 통해서 사용하면 된다.
    draw(){ // 상속받은 draw함수를 재정의 
        super.draw(); // 하지만 부모의 것도 쓰고싶기 때문에 super 키워드로 부모의 draw도 사용
        new code  // 새로운 코드로 결국엔 상속받은 크래스의 새로운 draw() 함수가 만들어짐 
    }

67. instanceof 
    child instanceof parent // 이렇게 띄어쓰기로 구분 
    자식이 부모의 인스턴스인가? 결국 이 부모로 부터 상속받은 자식인가 를 물음 // 리턴은 true, false

68. 예외 만들기
    throw Error("error message"); // 일부러 에러를 만들 수 있다. 보통 예외처리랑 같이씀

69. key와 value의 값이 동일하면 한개로 생략가능
    function re(name, age){
        return{
            name, // name = name
            age  //  age = age
        }
    }

70. 간단하게 객체의 key 확인하기
    'key' in obj // 띄어쓰기로 구분 key가 obj에 들어있다면 true 반환 
    "in" 이라는 키워드는 여기서도 그렇고 for문에서도 그렇고 객체와 관련이 있는듯

71. array_name.forEach() // for .. of 랑 같은 역활 
    간단하게 배열을 출력하는 함수로 콜백함수로 반복문이 돌면서 실행됨 
    콜백함수로의 인자로는 배열의 value값, 인덱스값, array 자체를 줄수있고 전부 생략 가능한 인자임 
    array.forEach((value, indx) => {  // 주로 array값은 잘 안씀 
        console.log(value, indx);
    });
    
72. 배열의 값 바꾸기  
    arr.push("value") // 맨뒤에 넣기
    arr.pop() // 맨뒤에서 하나 빼기, 이때 그 빼온값을 리턴해줌 
    arr.unshift("value") // // 맨앞부터 넣기
    arr.shift() // 맨앞에 하나 빼기, 이때 그빼온값을 리턴해줌 
    ※근데 unshift, shift는 배열전체가 움직여야되서 굉장히 느리고 가능한한 안쓰는게 좋음
    arry.sprice(a,b,c?) // 인덱스위치a 에있는 값을 b개 만큼 지울거야 // 없앤다음 그자리에 c 문자열을 추가할 수 있음   

73. 배열합치기
    let array3 = array1.concat(array2) // array1과 array2를 합침  

74. 배열에서 값으로 인덱스 찾기
    array.indexOf(value) // value가 array배열의 몇번째 인덱스인지 알려줌 >> 근데 없으면 -1 반환, 여러개면 첫번째만
    array.lastIndexOf(value) // 똑같은데 마지막 놈만 알려줌  

75. 배열의 값찾기 
    array.includes(value) // value가 array안에 있냐? 있으면 true반환 

76. join()
    배열의 모든 값을 인자로준 구분자를 더해서 string 으로 반환하는 함수 
    구분자를 주지않으면 default값으로 콤마(,)가 적용됨 

77. split()
    스트링타입의 메소드로 조인과 반대로 문자열을 인자로 준 구분자로 나누어서 
    하나하나 배열에 담는다. 난 slice()와 좀 이름이 헷갈림 

78. slice()
    배열의 특정 부분을 잘라서 새로울 배열을 만드는 메소드
    특징은 sprice()은 원본 배열을 잘르고 추가하고 할 수 있는 반면 slice()는 새로운 배열을 리턴함
    slice(2,5) >> 배열의 인덱스 2 ~ 4 잘라서 리턴함  

79. array.find(callback) // 콜백 인자 첫번째 = elment, 두번째 = index
    배열안에 있는 모든 요소마다 차례대로 호출이 되는데 요소를 가지고와서 하나씩 콜백함수가 동작함
    메소드이름인 find니까 콜백함수에서 내가 찾고싶은 로직이 true가 나오면 find가 그 요소값을 리턴해줌 
    단순한 배열에는 응용하기 힘들고, 객체가 들어있는 배열이 있다면 예를들어 Person이라는 객체의 인스턴스
    가 4담긴 배열에서 age의 값이 30이상인 객체를 찾는다 던지 할때 쓰면 유용하게 찾을 수 있음

80. array.filter(callback) 
    find랑 비슷하지만 find는 처음으로 조건에 맞는 거 한개만 가져온다면 
    filter는 콜백 조건에 맞는 모든 요소를 배열로 리턴해줌 

81. array.map(callback)
    배열의 모든 요소를 callback함수를 호출하여 callback으로 가공된 값으로 리턴하여  
    새로운배열을 리턴하는 매핑함수 

82. array.some(callback) 
    filter()함수처럼 모든 요소를 돌면서 콜백을 호출하는데 some은 배열을 체크하는 것임
    그래서 모든 조건중에 하나라도 만족하는 요소가 있으면 True를 반환

83. array.every(callback) 
    some()과는 반대로 모든 요소들이 조건을 만족해야지만 True를 반환

84. array.reduce() // 좀 어려움 , 배열을 돌면서 무언가를 누적할때 사용 
    result = array.reduce((prev, curr) => {
    return prev
    }, 0)
    ※prev와 curr 의 의미 : array 함수를 돌면서 인덱스 01 12 23 34 이런식으로 두개씩 묶어서 콜백하는 것
    prev는 누적값 curr는 현재 배열요소값을 뜻하고 리턴된 값이 다음 누적값이 되기 때문에 현재값을 리턴 하는것임
    그러면 인덱스 01 콜백하고 1이 리턴되서 다음 12 콜백하고 23 34 이렇게 모든 사이클을 돌게됨 
    콜백 뒤에 0의 의미는 인덱스0부터 사이클 돌겠다는 뜻으로 본인이 초기값 설정할 수 있다. // 디폴트는 0
    reduce가 강력한 것은 콜백으로 다양한 메소드를 만들 수 있는 것 // 모든항을 더한다 던지 

85. 블럭 사용으로 가독성 높이기
    {const result = students
        .map(student => student.score)
        .filter(value => value>50)
        .sort()
        .join()
        console.log(result);
    } ※메소드 사용할때 뒤에만 붙이는게 길고 한눈에 알아보기 어려웠는데
        이렇게 블럭안에서는 줄바꿈해서 사용할 수 있어서 가독성이 높아짐 


86. array.forEach(callback)
    얘도 결국 callback으로 요소값 쓸때 사용하는데 첫번째인자 value, 두번째 index임 


87. Object -> JSON포맷 
    JSON.stringify(obj) // 자바스크립트의 객체를 인자로 jSON포맷 문자열로 바꿔줌 
    여기서 말하는 자바스크립의 객체는 문자, 배열, 객체 등 모든 object를 말함
    이때 함수, Symbol 등은 jSON으로 바뀌지 않음

88. JSON포맷 -> Object
    jSON.parse(str) // 여기서 str은 JSON 포맷을 하고있는 문자열 
    이러면 리턴값은 자바스크립트의 객체로써 사용할 수 있다.

89. new Date() 
    날짜 객체 // Sun Feb 06 2022 16:16:05 GMT+0900 (한국 표준시)


90. setTimeout과 setInterval // delay만큼 시간이 지나고 원하는 함수를 호출할 수 있게 하는 함수
    setTimeout(func(), delay); // 1번만
    setInterval(func(), delay); // 무한루프 

91. 함수에 인자값 줄때 코드 깔끔하게 작성하기
    userStorage(
        id,
        password,
        (user) => {},
        (error) => {}
    )※ 이렇게 인자가 값, 콜백함수가 섞여 길어질때 깔끔하게 이렇게 인자값을 작성하면 가독성이 좋음


92. promise의 약속 
    즉 내가 언제 이 heavy logic을 다 처리할지는 모르겠지만 내가 이거 하나만은 꼭 약속할게,
    너가 promise 객체를 만들어 놓고 then 이라는 콜백함수를 등록해 놓으면 logic이 준비되는 대로 너가 
    준비해놓은 then의 콜백함수를 반드시 불러줄게 


93. promise
    자바스크립트 내장 객체로 비동기처리시 콜백 대신에 유용하게 쓸수있음
    생성할때 excutor 라는 콜백함수를 생성자로 전달을 해야되는데 이 excutor 콜백함수는 또 2개의 
    resolve와 reject라는 콜백함수를 받는다 // resolve는 정상적인 호출, 중간에 문제생기면 호출하는 reject
    ※새로운 promise를 만드는 순간 자동으로 excutor라는 콜백함수가 바로 실행된다. 
    // producer
    let promise = new Promise((resolve,reject)=>{
        // heavy work(network, file read)
        resolve("hello");
    })
    // consumers
    promise.then(value => {logic})
    ※ 이처럼 promise를 정의해여 excutor가 실행되고 안에 네트워크작업과 같은 heavy한일 이 실행되어서 
    비동기 처리가 됨 그리고 시간이 지나서 작업이 완료되면 resolve, 에러나면 reject 콜백함수를 호출하고
    resolve는 then으로 reject는 catch로 결과값을 보내줌 그러면 then, catch는 다시 콜백함수를 선언 하고 
    보내준 그 결과값이 콜백함수의 인자값으로 들어오게됨 

94. promise 테크닉
    주로 함수에 안에다가 promise객체를 선언해서 이름없이 리턴으로 선언해준다 
    const login = (id, pw) => {
        return new Promise((resolve, reject) => {
            적당한 ~ id, pw를 사용한 로직 
            if(조건){
                resolve()
            }else{
                reject()
            }
        })
    }

    login(id, pw).then()  // 이런식으로 사용 


95. async & await 
    promise방식을 좀더 깔끔하게 사용할 수 있는 api // 하지만 누가더 좋고 나쁘고는 절대 아님 
    
    1. async 
        함수 앞에 async 키워드를 입력하면 자동으로 블럭이 promise객체로 바뀜
        async function user(){ return value }
        user().then()
        
    2. await
        async가 붙은 함수에서만 사용 가능한 키워드
        기존의 promise에서는 로직이 끝나길 기다리다가 그 resolve로 온 값에 then 콜백을 주었는데
        await heavy() // 이렇게 await키워드를 달아서 끝날때 까지 기다려 라는 의미 
        return next_logic // 기다림이 끝났으면 다음일 처리해 
        ※이런식으로 실제는 promise랑 같지만 마치 동기적으로 처리 하는것 보이게 코드를 짤수있다.

96. 조건문 테크닉
    if(조건){ logic } // 한줄로 작성할 수 있는 짧은 코드라면 이렇게 코드를 짜는 것보다 
    조건 && logic // 이렇게 조건이 참일때만 logic이 실행하는 and 연산자를 쓰는 것이 보기좋음

97. 생성자에서 콜백함수 받을때 
    constant(verb, func){
        this.verb = verb 
        this.func = func  
    } ※ 이렇게 문자 초기화 할때 처럼 함수도 똑같이 초기호함 = func() 이렇게 아님 
    











제네릭? 


toString




 























 

